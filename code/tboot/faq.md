FAQ: Get TBoot up and running in no time
========================================

`>` I press `ENTER` but see nothing.

1. Is there any inversion on the MCU TX line by any chance?<br>
   If yes, then assemble with the option `-dTXINV` to set the TX line as inverted.

2. Try the same suggestions as the following issue.

`>` I see the menu but commands return `Error`.

Assuming there are no hardware issues/noise on your MCU side SCI RX line, I would check the following:

1. Is there any inversion on the MCU RX line by any chance?<br>
   If yes, then assemble with the option `-dRXINV` to set the RX line as inverted.

2. You can change the baud rate with `-dBPS=rate` (for example `-dBPS=38400`) to one with 0% error (if any for the given frequency of operation).

3. If no bps rate gives 0% error, a default bps choice with an error of 1.13% or more could potentially create problems in combination with a non-ideal trim.

Try assembling with `-dHZ=38400*512` (or whatever other suitable value) which gives a zero error bps max rate.  This means you will also need to adjust the P&E algorithm accordingly so that it uses the correct trim value (if you don't know how I can help).

The bootloader understands plain ASCII commands.
Send your firmware as S19 (or S28 for MMU) format with simple copy paste (as if you actually typed the S19 file content by hand).

Windows console tip: You can do `clip < firmware.s19` to have your `firmware.s19` file copied to the clipboard.  If you make this part of your makefile build process, you'll be ready to just paste the code as soon as the build finishes.

`>` Why separate `[E]rase` and `[L]oad` options.  Couldn't `[L]oad` first erase?

It would be possible for `[L]oad` to first erase and then start the loading process.  It was actually done this way in earlier TBoot versions.  However, there are circumstances that firmware is loaded in pieces (e.g., code and separate image), and that would not be possible if each `[L]oad` command first erased all memory.

`>` I am getting Address Range error. I did do `[E]rase` first.<br>
`>` `RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR!`

TBoot by default allocates a single Flash page (whatever the size happens to be for the particular MCU variant) for user configuration.  This is controlled by the `FLASH_DATA_SIZE` constant.

Placing code in that area is not allowed by default.  The idea is you normally want to protect your user's existing configuration when updating the app to a newer version.  And should your data format change, you can always have your app overwrite it with or convert it to the new one.

So, your options are:

1. Zero the size of the reserved-by-default configuration area by adding `-dFLASH_DATA_SIZE` to your assembly process (if your app does not require any user configuration memory).

2. Move your application to start at `$E200` (instead of `$E000`) in the case of QE8, or similar for other MCU variants.  In other words, move the app code to the beginning of the sector right after the reserved one for user configuration.

3. Add `-dALLOW_EEPROM` to your assembly process to enable erasing & programming of the reserved data flash used as simulated EEPROM. (Not recommended.)

If you also add the `-exp` option to `asm8` you will get a file ending with `.exp` extension.  This file shows something like the following:

```
; Generated by ASM8 v9.98 Win32 [Monday, January 4, 2021  5:55 pm]

bps_300             set       $0DA7,0
bps_1200            set       $0369,0
bps_2400            set       $01B4,0
bps_4800            set       $00DA,0
bps_9600            set       $006D,0
bps_19200           set       $0036,0
bps_38400           set       $001B,0
bps_57600           set       $0012,0
bps_115200          set       $0009,0
APP_CODE_START      set       $E200,0
APP_CODE_END        set       $FBFF,0
BOOTROM             set       $FC00,0
BOOTRAM_END         set       $0080,0
BOOTROM_VERSION     set       $0074,0
RVECTORS            set       $FBC0,0
```

As you can see `APP_CODE_START` and `APP_CODE_END` are the limits of your application memory.

If you zero the size of the flash set aside by default with `-dFLASH_DATA_SIZE` then you will get this for `APP_CODE_xxx`:
```
APP_CODE_START      set       $E000,0
APP_CODE_END        set       $FBFF,0
```
Your app (including the redirected vectors) should lie between these two addresses (inclusive).

The vectors can be defined in their default location or their redirected location (both will work).  If using the default locations, TBoot will manage them automatically and move them to end at the end at `APP_CODE_END`.

So, your actual app excluding the vectors should extend no more than one byte before the redirected vectors, see symbol `RVECTORS`.

`>` What other error codes are possible?

* `.` means successful programming of a single S-record.
* `!` means the S9/S8 record was read, and the loading process stopped.
* `F` means Flash error.  The specific location could not be programmed.
* `C` means S-record CRC mismatch.
* `R` means Range Error in that the booloader does not expect records outside predetermined memory addresses.

A successful programming session would be a series of dots (one for each S-record), followed by a single `!` to indicate the reading of the final S9/S8 record.

A few more notes to keep this a bit more complete.

1. `ESC` resets the MCU, and if the conditions are right (i.e. no IRQ held low, and some app seems to be present, i.e., the redirected reset vector points to within valid app range) it will run your app, otherwise, it will end up back in TBoot.

2. TBoot stays out of the way when your program runs, and unless I missed something by oversight, leaves all registers in their default state while not affecting any of the one-time writable registers.  This means except for taking up about 800 bytes of your ROM space (alright, 1 KB really, due to Flash protection limitations), it is as if it does not exist.

3. Keep the IRQ pin low while powering up to have it gain control again.  (This can be disabled with `-dDISABLE_IRQ` and rely on other method to update your app -- like 4 below -- but usually it's a good thing to have in case your app ever loses control.  As the IRQ pin is only checked during reset, and freed to default state afterwards it should not be a problem for most applications.  In practice, the only exception is those applications that receive pulses on the IRQ pin **before** the MCU has enough time to enter the application.)

4. You can have your app jump to TBoot directly (no need for hardware intervention to hold IRQ low), by the following method, shown in assembly language:

```
                    ldhx      Vreset    ;true reset vector at $FFFE
                    cli                 ;flag to TBoot that this is software entry
                    jmp       ,x        ;execute Monitor
```

Regarding specifying include directories, it's really simple.  The default search order for relative path filenames is

1. Current file path
2. Main file path
3. Root directory, specified by the presence of a filename `_asm_`.

The default order and/or additional search paths can be specified with the `-I` option and (optionally) saved in a asm8.cfg file.  But, I find the default order works the best for most, if not all, cases.
